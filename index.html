<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dune Search | Sortphy</title>
  <link rel="icon" href="./images/sortphy.png">
  <!-- Import canvas-confetti from CDN if you need the original one elsewhere -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      text-align: center;
      font-size: 2.5rem;
      margin-bottom: 0;
    }
    /* GitHub repo link styling */
    .repo-link {
      text-align: center;
      font-size: 0.8rem;
      margin-top: 5px;
      color: #333;
    }
    .repo-link a {
      color: #333;
      text-decoration: none;
    }
    .repo-link a:hover {
      text-decoration: underline;
    }
    .main-container {
      display: flex;
      flex-direction: column;
      gap: 30px;
    }
    .top-section {
      display: flex;
      justify-content: space-between;
      gap: 20px;
    }
    .book-selection, .search-section, .results-section {
      flex: 1;
    }
    .book-selection h2, .search-section h2, .results-section h2 {
      margin-top: 0;
    }
    .books {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }
    .book {
      cursor: pointer;
      transition: all 0.3s;
      width: 100px;
      position: relative;
    }
    .book img {
      width: 100%;
      height: auto;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .book.selected {
      transform: scale(1.1);
    }
    .book.selected::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 3px solid #ff6b00;
      box-shadow: 0 0 15px rgba(255, 107, 0, 0.5);
    }
    .search-input {
      width: 100%;
      padding: 8px;
      font-size: 16px;
      margin-top: 10px;
    }
    .search-btn {
      margin-top: 10px;
      padding: 8px 16px;
      background-color: #333;
      color: white;
      border: none;
      cursor: pointer;
    }
    .results-display {
      background-color: #e4e4e4;
      padding: 15px;
      min-height: 200px;
      margin-top: 10px;
      margin-left: 10px;
      border-radius: 5px;
      overflow-y: auto;
    }
    .text-display {
      background-color: #e4e4e4;
      color: #000000;
      padding: 20px;
      margin-top: 20px;
      border-radius: 5px;
      height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      position: relative;
    }
    .highlight-current {
      background-color: #ffcc00;
    }
    .highlight-match {
      background-color: #adff2f;
    }
    .loading {
      text-align: center;
      font-style: italic;
      color: #666;
    }
    .algorithm-status {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    .algorithm-box {
      flex: 1;
      padding: 10px;
      margin: 0 5px;
      background-color: #f0f0f0;
      border-radius: 5px;
      text-align: center;
    }
    .progress-bar {
      height: 10px;
      background-color: #ddd;
      border-radius: 5px;
      margin-top: 5px;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background-color: #4CAF50;
      width: 0%;
      transition: width 0.3s;
    }
    .control-panel {
      display: flex;
      justify-content: space-between;
      background-color: #f5f5f5;
      padding: 15px;
      border-radius: 5px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    .toggle-container,
    .delay-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
      margin-left: 10px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #2196F3;
    }
    input:focus + .slider {
      box-shadow: 0 0 1px #2196F3;
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    .delay-input {
      width: 60px;
      margin-left: 10px;
      padding: 5px;
    }
    /* New CSS for hiding positions */
    .hidden {
      display: none;
    }
    /* Canvas styles for dune confetti */
    #confetti-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9999;
    }
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .top-section {
        flex-direction: column;
      }
      .control-panel {
        flex-direction: column;
        align-items: flex-start;
      }
    }
    @media (max-width: 480px) {
      h1 {
        font-size: 2rem;
      }
      .search-input {
        font-size: 14px;
      }
      .search-btn {
        font-size: 14px;
        padding: 6px 12px;
      }
      .algorithm-status {
        flex-direction: column;
      }
      .algorithm-box {
        margin: 5px 0;
      }
    }
  </style>
</head>
<body>
  <!-- Dune Confetti Canvas -->
  <canvas id="confetti-canvas"></canvas>
  
  <h1>DUNE SEARCH</h1>
  <p class="repo-link">GitHub Repo: <a href="https://github.com/Sortphy/dune-search" target="_blank">https://github.com/Sortphy/dune-search</a></p>
  
  <div class="main-container">
    <div class="top-section">
      <div class="book-selection">
        <h2>Selecione o livro</h2>
        <div class="books">
          <div class="book" data-book="dune1">
            <img src="images/dune1.jpg" alt="Dune">
          </div>
          <div class="book" data-book="dune2">
            <img src="images/dune2.jpg" alt="Dune Messiah">
          </div>
          <div class="book" data-book="dune3">
            <img src="images/dune3.jpg" alt="Children of Dune">
          </div>
        </div>
      </div>
      
      <div class="search-section">
        <h2>Buscar por:</h2>
        <input type="text" class="search-input" placeholder="Digite a palavra ou frase..." value="Caladan">
        <button class="search-btn">Buscar</button>
        
        <div class="control-panel">
          <div class="toggle-container">
            <span>Visualização:</span>
            <label class="toggle-switch">
              <input type="checkbox" id="visualization-toggle" checked>
              <span class="slider"></span>
            </label>
          </div>
          <div class="delay-container">
            <span>Delay (ms):</span>
            <input type="number" id="delay-input" class="delay-input" value="10" min="0" max="1000">
          </div>
        </div>
      </div>
      
      <div class="results-section">
        <h2>Resultados:</h2>
        <div class="results-display">
          <div class="loading">Selecione um livro e inicie a busca</div>
        </div>
        <div class="algorithm-status">
          <div class="algorithm-box">
            <div>Naive Search: <span class="naive-time">-</span></div>
            <div class="progress-bar"><div class="naive-progress progress-fill"></div></div>
          </div>
          <div class="algorithm-box">
            <div>Rabin-Karp: <span class="rk-time">-</span></div>
            <div class="progress-bar"><div class="rk-progress progress-fill"></div></div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="text-display">
      <div class="loading">O texto do livro será exibido aqui</div>
    </div>
  </div>

  <script>
    // Book content will be stored here when loaded
    let bookContent = '';
    let selectedBook = null;
    let isSearching = false;
    let visualizationEnabled = true;
    let visualizationDelay = 10; // ms
    let updateFrequency = 1000; // Check every 1000 positions
    
    // DOM Elements
    const books = document.querySelectorAll('.book');
    const searchInput = document.querySelector('.search-input');
    const searchBtn = document.querySelector('.search-btn');
    const resultsDisplay = document.querySelector('.results-display');
    const textDisplay = document.querySelector('.text-display');
    const naiveTimeDisplay = document.querySelector('.naive-time');
    const rkTimeDisplay = document.querySelector('.rk-time');
    const naiveProgress = document.querySelector('.naive-progress');
    const rkProgress = document.querySelector('.rk-progress');
    const visualizationToggle = document.getElementById('visualization-toggle');
    const delayInput = document.getElementById('delay-input');
    
    // Set up visualization controls
    visualizationToggle.addEventListener('change', function() {
      visualizationEnabled = this.checked;
      delayInput.disabled = !visualizationEnabled;
      
      if (!visualizationEnabled) {
        updateFrequency = Number.MAX_SAFE_INTEGER; // Effectively disable updates
      } else {
        updateFrequency = 1000; // Reset to default
        visualizationDelay = parseInt(delayInput.value) || 10;
      }
    });
    
    delayInput.addEventListener('change', function() {
      visualizationDelay = parseInt(this.value) || 10;
    });
    
    // Set up book selection
    books.forEach(book => {
      book.addEventListener('click', () => {
        if (isSearching) return;
        
        // Update selection visual
        books.forEach(b => b.classList.remove('selected'));
        book.classList.add('selected');
        
        // Get selected book
        selectedBook = book.dataset.book;
        
        // Load book content
        loadBookContent(selectedBook);
      });
    });
    
    // Set up search button
    searchBtn.addEventListener('click', () => {
      if (!selectedBook) {
        alert('Por favor, selecione um livro primeiro.');
        return;
      }
      
      if (isSearching) return;
      
      const searchPattern = searchInput.value.trim();
      if (searchPattern === '') {
        alert('Por favor, digite algo para buscar.');
        return;
      }
      
      runSearch(searchPattern);
    });
    
    // Function to load book content
    function loadBookContent(book) {
      textDisplay.innerHTML = '<div class="loading">Carregando o texto do livro...</div>';
      resultsDisplay.innerHTML = '<div class="loading">Selecione uma palavra ou frase para buscar</div>';
      
      // In a real application, you would load the actual book content.
      // For this demo, we'll simulate loading with some text.
      fetch(`books/${book}.txt`)
        .then(response => {
          if (!response.ok) {
            throw new Error('Arquivo não encontrado');
          }
          return response.text();
        })
        .then(text => {
          bookContent = text;
          textDisplay.textContent = text;
        })
        .catch(error => {
          console.error('Error loading book:', error);
          textDisplay.innerHTML = `<div class="loading">Erro ao carregar o livro: ${error.message}</div>`;
          
          // For demo purposes, load sample text if file not found
          bookContent = `This is sample text for ${book}. The Atreides family lived on Caladan for generations before moving to Arrakis. 
          Paul Atreides remembered Caladan as a planet of water and mild climate.
          Duke Leto often missed Caladan during his time on Dune. Caladan remained a part of the Atreides heritage.`;
          
          textDisplay.textContent = bookContent;
        });
    }
    
    // Naive Search Algorithm with visualization
    async function naiveSearch(text, pattern, updateProgress) {
      const occurrences = [];
      const textLength = text.length;
      const patternLength = pattern.length;
      
      // Edge cases
      if (patternLength > textLength) return [];
      if (patternLength === 0) return [];
      
      // Clear previous highlights if visualization is enabled
      if (visualizationEnabled) {
        updateTextDisplay(text);
      }
      
      // Brute force search with visualization
      for (let i = 0; i <= textLength - patternLength; i++) {
        let match = true;
        
        // Update progress periodically if visualization is enabled
        if (visualizationEnabled && (i % updateFrequency === 0 || i === 0)) {
          await new Promise(resolve => setTimeout(resolve, 0)); // Let the UI breathe
          updateProgress(i / (textLength - patternLength + 1));
          highlightCurrent(i, patternLength, 'examining');
        }
        
        for (let j = 0; j < patternLength; j++) {
          if (text[i + j] !== pattern[j]) {
            match = false;
            break;
          }
        }
        
        if (match) {
          occurrences.push(i);
          if (visualizationEnabled) {
            highlightMatch(i, patternLength);
            await new Promise(resolve => setTimeout(resolve, visualizationDelay));
          }
        }
      }
      
      // Update progress to 100% at the end
      updateProgress(1);
      
      return occurrences;
    }
    
    // Rabin-Karp Search Algorithm with visualization
    async function rabinKarpSearch(text, pattern, updateProgress) {
      const occurrences = [];
      const textLength = text.length;
      const patternLength = pattern.length;
      
      // Edge cases
      if (patternLength > textLength) return [];
      if (patternLength === 0) return [];
      
      // Clear previous highlights but keep matches from naive search
      if (visualizationEnabled) {
        updateTextDisplay(text, true);
      }
      
      // Prime number for hash calculation
      const prime = 101;
      
      // Function to calculate hash value
      function hash(str, end) {
        let hashValue = 0;
        for (let i = 0; i < end; i++) {
          hashValue += str.charCodeAt(i) * Math.pow(prime, i);
        }
        return hashValue;
      }
      
      // Calculate hash for pattern and initial window
      const patternHash = hash(pattern, patternLength);
      let textHash = hash(text, patternLength);
      
      // Search with visualization
      for (let i = 0; i <= textLength - patternLength; i++) {
        // Update progress periodically if visualization is enabled
        if (visualizationEnabled && (i % updateFrequency === 0 || i === 0)) {
          await new Promise(resolve => setTimeout(resolve, 0)); // Let the UI breathe
          updateProgress(i / (textLength - patternLength + 1));
          highlightCurrent(i, patternLength, 'examining-rk');
        }
        
        // Check if hash values match
        if (patternHash === textHash) {
          // Verify character by character
          let match = true;
          for (let j = 0; j < patternLength; j++) {
            if (text[i + j] !== pattern[j]) {
              match = false;
              break;
            }
          }
          if (match) {
            occurrences.push(i);
            if (visualizationEnabled) {
              highlightMatch(i, patternLength, 'match-rk');
              await new Promise(resolve => setTimeout(resolve, visualizationDelay));
            }
          }
        }
        
        // Calculate hash for next window
        if (i < textLength - patternLength) {
          textHash = textHash - text.charCodeAt(i);
          textHash = textHash / prime;
          textHash += text.charCodeAt(i + patternLength) * Math.pow(prime, patternLength - 1);
        }
      }
      
      updateProgress(1);
      return occurrences;
    }
    
    // Function to update text display
    function updateTextDisplay(text, keepMatches = false) {
      if (!visualizationEnabled) {
        textDisplay.textContent = text;
        return;
      }
      
      if (!keepMatches) {
        textDisplay.textContent = text;
      } else {
        const spans = textDisplay.querySelectorAll('.highlight-current');
        spans.forEach(span => {
          const textNode = document.createTextNode(span.textContent);
          span.parentNode.replaceChild(textNode, span);
        });
      }
    }
    
    // Function to highlight current position being examined
    function highlightCurrent(index, length, className = 'examining') {
      if (!visualizationEnabled) return;
      
      const oldSpans = textDisplay.querySelectorAll('.highlight-current');
      oldSpans.forEach(span => {
        const textNode = document.createTextNode(span.textContent);
        span.parentNode.replaceChild(textNode, span);
      });
      
      const textContent = textDisplay.textContent;
      const beforeText = textContent.substring(0, index);
      const highlightText = textContent.substring(index, index + length);
      const afterText = textContent.substring(index + length);
      
      textDisplay.textContent = '';
      textDisplay.appendChild(document.createTextNode(beforeText));
      
      const span = document.createElement('span');
      span.className = 'highlight-current';
      span.textContent = highlightText;
      textDisplay.appendChild(span);
      
      textDisplay.appendChild(document.createTextNode(afterText));
      span.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    
    // Function to highlight matches
    function highlightMatch(index, length, className = 'match') {
      if (!visualizationEnabled) return;
      
      const textContent = textDisplay.textContent;
      const beforeText = textContent.substring(0, index);
      const matchText = textContent.substring(index, index + length);
      const afterText = textContent.substring(index + length);
      
      textDisplay.textContent = '';
      textDisplay.appendChild(document.createTextNode(beforeText));
      
      const span = document.createElement('span');
      span.className = 'highlight-match';
      span.textContent = matchText;
      textDisplay.appendChild(span);
      
      textDisplay.appendChild(document.createTextNode(afterText));
    }
    
    // Dune-themed confetti variables and functions
const canvas = document.getElementById('confetti-canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Array with dune-themed image paths; ensure these images exist in /images/dune/
const duneImages = [
  './images/dune/1.png',
  './images/dune/2.png',
  './images/dune/3.png',
  './images/dune/4.png',
  './images/dune/5.png'
];

const confettiCount = 50;
const confettiPieces = [];
let animationFrameId;

// For explosion effect, each confetti piece is spawned at the bottom center
// and given a velocity calculated from a random angle (between 200° and 340°) 
// and a random initial speed.
class Confetti {
  constructor() {
    this.image = new Image();
    this.image.src = duneImages[Math.floor(Math.random() * duneImages.length)];
    // Start from the bottom-center of the canvas.
    this.x = canvas.width / 2;
    this.y = canvas.height;
    // Set a random angle between 200° and 340° (in radians)
    const angle = (200 + Math.random() * 140) * Math.PI / 180;
    // Initial speed between 4 and 8 pixels per frame.
    const speed = 8 + Math.random() * 4;
    this.vx = speed * Math.cos(angle);
    this.vy = speed * Math.sin(angle);
    this.size = 50 + Math.random() * 24;
    this.rotation = Math.random() * 360;
    this.rotationSpeed = Math.random() * 5 - 1;
    // Gravity to pull the particles down gradually.
    this.gravity = 0.025;
  }

  update() {
    // Update position with current velocity.
    this.x += this.vx;
    this.y += this.vy;
    // Apply gravity (affects vertical velocity).
    this.vy += this.gravity;
    this.rotation += this.rotationSpeed;
  }

  draw() {
    ctx.save();
    // Translate to the current position.
    ctx.translate(this.x, this.y);
    // Rotate the context according to the current rotation.
    ctx.rotate(this.rotation * Math.PI / 180);
    // Draw the image centered at (0,0).
    ctx.drawImage(this.image, -this.size / 2, -this.size / 2, this.size, this.size);
    ctx.restore();
  }
}

function initConfetti() {
  // Clear any previous confetti pieces.
  confettiPieces.length = 0;
  for (let i = 0; i < confettiCount; i++) {
    confettiPieces.push(new Confetti());
  }
  animateConfetti();
}

function animateConfetti() {
  // Clear the canvas on each frame.
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  confettiPieces.forEach(piece => {
    piece.update();
    piece.draw();
  });
  // Store the requestAnimationFrame ID so we can cancel it later.
  animationFrameId = requestAnimationFrame(animateConfetti);
}

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

// Function to stop the confetti animation
function stopConfetti() {
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
    // Optionally, clear the canvas after stopping.
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
}

// Function to trigger the Dune-themed confetti explosion from the bottom.
// The confetti is animated and then stops after 5 seconds.
function triggerConfetti() {
  initConfetti();
  setTimeout(stopConfetti, 2500);
}

    
    // Function to run search benchmark
    async function runSearch(pattern) {
      if (isSearching) return;
      isSearching = true;
      
      naiveTimeDisplay.textContent = '-';
      rkTimeDisplay.textContent = '-';
      naiveProgress.style.width = '0%';
      rkProgress.style.width = '0%';
      resultsDisplay.innerHTML = '<div class="loading">Buscando...</div>';
      
      try {
        console.log('Running Naive Search...');
        const naiveStartTime = performance.now();
        const naiveResults = await naiveSearch(bookContent, pattern, (progress) => {
          naiveProgress.style.width = `${progress * 100}%`;
        });
        const naiveEndTime = performance.now();
        const naiveTime = naiveEndTime - naiveStartTime;
        naiveTimeDisplay.textContent = `${naiveTime.toFixed(2)} ms`;
        
        console.log('Running Rabin-Karp Search...');
        const rkStartTime = performance.now();
        const rkResults = await rabinKarpSearch(bookContent, pattern, (progress) => {
          rkProgress.style.width = `${progress * 100}%`;
        });
        const rkEndTime = performance.now();
        const rkTime = rkEndTime - rkStartTime;
        rkTimeDisplay.textContent = `${rkTime.toFixed(2)} ms`;
        
        const performanceDiff = Math.abs(((naiveTime / rkTime) - 1) * 100).toFixed(2);
        const fasterAlgo = naiveTime > rkTime ? 'Rabin-Karp' : 'Naive Search';
        const resultsMatch = naiveResults.length === rkResults.length &&
                             JSON.stringify(naiveResults) === JSON.stringify(rkResults);
        
        let resultsHTML = `
          <h3>Resultados da Busca:</h3>
          <p><strong>Termo buscado:</strong> "${pattern}"</p>
          <p><strong>Naive Search:</strong></p>
          <ul>
            <li>Ocorrências encontradas: ${naiveResults.length}</li>
            <li>Tempo de execução: ${naiveTime.toFixed(4)} ms</li>
          </ul>
          <p><strong>Rabin-Karp Search:</strong></p>
          <ul>
            <li>Ocorrências encontradas: ${rkResults.length}</li>
            <li>Tempo de execução: ${rkTime.toFixed(4)} ms</li>
          </ul>
          <p><strong>Diferença de performance:</strong> ${performanceDiff}% mais rápido com ${fasterAlgo}</p>
          <p><strong>Check de consistência:</strong> ${resultsMatch ? 'PASSOU' : 'FALHOU'}</p>
        `;
        
        // Update positions display with "view more" if more than 5 results
        if (naiveResults.length > 0) {
          let positionsHTML = `<p><strong>Posições encontradas:</strong></p>
            <div id="positions-container">`;
          naiveResults.forEach((pos, index) => {
            if (index < 5) {
              positionsHTML += `<span class="position">${pos}${index < 4 ? ', ' : ''}</span>`;
            } else {
              positionsHTML += `<span class="position hidden">${pos}${index < naiveResults.length - 1 ? ', ' : ''}</span>`;
            }
          });
          positionsHTML += `</div>`;
          if (naiveResults.length > 5) {
            positionsHTML += `<button id="toggle-view">Ver mais</button>`;
          }
          resultsHTML += positionsHTML;
        }
        
        resultsDisplay.innerHTML = resultsHTML;
        
        // Set up the toggle functionality for hidden positions
        const toggleBtn = document.getElementById('toggle-view');
        if (toggleBtn) {
          toggleBtn.addEventListener('click', () => {
            const hiddenPositions = document.querySelectorAll('#positions-container .hidden');
            hiddenPositions.forEach(el => el.classList.remove('hidden'));
            toggleBtn.style.display = 'none';
          });
        }
        
        if (visualizationEnabled) {
          updateTextDisplay(bookContent);
          for (const position of naiveResults) {
            highlightMatch(position, pattern.length);
          }
        } else {
          textDisplay.textContent = bookContent;
        }
        
        // Trigger the Dune-themed confetti effect upon completion of search
        triggerConfetti();
        
      } catch (error) {
        console.error('Error during search:', error);
        resultsDisplay.innerHTML = `<p>Erro durante a busca: ${error.message}</p>`;
      } finally {
        isSearching = false;
      }
    }
    
    // Initialize with first book selected (for demo purposes)
    if (books.length > 0) {
      books[0].click();
    }
  </script>
</body>
</html>
